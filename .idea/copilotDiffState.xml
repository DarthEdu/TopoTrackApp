<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/epdev/topotrackapp/ui/polygon/PolygonFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/epdev/topotrackapp/ui/polygon/PolygonFragment.kt" />
              <option name="originalContent" value="package com.epdev.topotrackapp.ui.polygon&#10;&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import com.epdev.topotrackapp.databinding.FragmentPolygonBinding&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.overlay.Marker&#10;import org.osmdroid.views.overlay.Polygon&#10;import org.osmdroid.views.overlay.Polyline&#10;&#10;class PolygonFragment : Fragment() {&#10;&#10;    private var _binding: FragmentPolygonBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val viewModel: PolygonViewModel by viewModels()&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentPolygonBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        binding.mapPolygon.setMultiTouchControls(true)&#10;&#10;        viewModel.points.observe(viewLifecycleOwner) { points -&gt;&#10;            binding.mapPolygon.overlays.clear()&#10;&#10;            if (points.isNullOrEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;No hay puntos disponibles&quot;, Toast.LENGTH_SHORT).show()&#10;                binding.progressBar.visibility = View.GONE&#10;                return@observe&#10;            }&#10;&#10;            drawMarkers(points)&#10;&#10;            if (points.size &gt;= 3) {&#10;                drawPolygon(points)&#10;                val area = viewModel.calcularAreaMetrosCuadrados(points)&#10;                binding.textPolygon.text = &quot; Área: %.2f m²&quot;.format(area)&#10;            } else {&#10;                drawDecorativeShape(points)&#10;                Toast.makeText(requireContext(), &quot;Se necesitan al menos 3 puntos para formar un polígono&quot;, Toast.LENGTH_LONG).show()&#10;                binding.textPolygon.text = &quot;Área: No disponible&quot;&#10;            }&#10;&#10;            binding.progressBar.visibility = View.GONE&#10;            binding.mapPolygon.invalidate()&#10;        }&#10;&#10;        binding.progressBar.visibility = View.VISIBLE&#10;        viewModel.fetchUbicaciones()&#10;    }&#10;&#10;    private fun drawMarkers(points: List&lt;GeoPoint&gt;) {&#10;        for ((index, point) in points.withIndex()) {&#10;            val marker = Marker(binding.mapPolygon).apply {&#10;                position = point&#10;                title = &quot; Punto ${index + 1}&quot;&#10;                setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;            }&#10;            binding.mapPolygon.overlays.add(marker)&#10;        }&#10;    }&#10;&#10;    private fun drawPolygon(points: List&lt;GeoPoint&gt;) {&#10;        val polygon = Polygon().apply {&#10;            fillPaint.color = Color.argb(80, 0, 255, 0)&#10;            outlinePaint.color = Color.GREEN&#10;            outlinePaint.strokeWidth = 5f&#10;            setPoints(points + points.first())&#10;        }&#10;        binding.mapPolygon.overlays.add(polygon)&#10;    }&#10;&#10;    private fun drawDecorativeShape(points: List&lt;GeoPoint&gt;) {&#10;        val polyline = Polyline().apply {&#10;            setPoints(points)&#10;            color = Color.YELLOW&#10;            width = 6f&#10;            isGeodesic = true&#10;        }&#10;        binding.mapPolygon.overlays.add(polyline)&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.epdev.topotrackapp.ui.polygon&#10;&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.viewModels&#10;import com.epdev.topotrackapp.databinding.FragmentPolygonBinding&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.overlay.Marker&#10;import org.osmdroid.views.overlay.Polygon&#10;import org.osmdroid.views.overlay.Polyline&#10;&#10;class PolygonFragment : Fragment() {&#10;&#10;    private var _binding: FragmentPolygonBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val viewModel: PolygonViewModel by viewModels()&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentPolygonBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        binding.mapPolygon.setMultiTouchControls(true)&#10;        binding.mapPolygon.overlays.clear()&#10;        binding.mapPolygon.invalidate()&#10;&#10;        viewModel.points.observe(viewLifecycleOwner) { points -&gt;&#10;            binding.mapPolygon.overlays.clear()&#10;&#10;            if (points.isNullOrEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;No hay puntos disponibles&quot;, Toast.LENGTH_SHORT).show()&#10;                binding.textPolygon.text = &quot;Área: No disponible&quot;&#10;                return@observe&#10;            }&#10;&#10;            drawMarkers(points)&#10;&#10;            if (points.size &gt;= 3) {&#10;                drawPolygon(points)&#10;                val area = viewModel.calcularAreaMetrosCuadrados(points)&#10;                binding.textPolygon.text = &quot;\uD83D\uDCCD Área: %.2f m²&quot;.format(area)&#10;            } else {&#10;                drawDecorativeShape(points)&#10;                Toast.makeText(requireContext(), &quot;Se necesitan al menos 3 puntos para formar un polígono&quot;, Toast.LENGTH_LONG).show()&#10;                binding.textPolygon.text = &quot;Área: No disponible&quot;&#10;            }&#10;&#10;            binding.mapPolygon.invalidate()&#10;        }&#10;&#10;        viewModel.fetchUbicaciones()&#10;    }&#10;&#10;    private fun drawMarkers(points: List&lt;GeoPoint&gt;) {&#10;        for ((index, point) in points.withIndex()) {&#10;            val marker = Marker(binding.mapPolygon).apply {&#10;                position = point&#10;                title = &quot;\uD83D\uDCCD Punto ${index + 1}&quot;&#10;                setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;            }&#10;            binding.mapPolygon.overlays.add(marker)&#10;        }&#10;    }&#10;&#10;    private fun drawPolygon(points: List&lt;GeoPoint&gt;) {&#10;        val polygon = Polygon().apply {&#10;            fillPaint.color = Color.argb(80, 0, 255, 0)&#10;            outlinePaint.color = Color.GREEN&#10;            outlinePaint.strokeWidth = 5f&#10;            setPoints(points + points.first())&#10;        }&#10;        binding.mapPolygon.overlays.add(polygon)&#10;    }&#10;&#10;    private fun drawDecorativeShape(points: List&lt;GeoPoint&gt;) {&#10;        val polyline = Polyline().apply {&#10;            setPoints(points)&#10;            color = Color.YELLOW&#10;            width = 6f&#10;            isGeodesic = true&#10;        }&#10;        binding.mapPolygon.overlays.add(polyline)&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>